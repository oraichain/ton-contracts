#include "auth_info.fc";
#include "tx_body.fc";
#include "varint.fc";

;; if (message.body !== undefined) {
;;   TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();
;; }
;; if (message.authInfo !== undefined) {
;;   AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();
;; }
;; for (const v of message.signatures) {
;;   writer.uint32(26).bytes(v!);
;; }
;; return writer;
tuple tx_raw::encode(tuple auth_info, tuple tx_body, tuple signatures){
    tuple return_tuple = empty_tuple();
    ;; auth_info extract
    tuple sign_infos = auth_info.at(0);
    tuple fees = auth_info.at(1);
    tuple tip = auth_info.at(2);
    ;; tx_body extract
    tuple msgs = tx_body.at(0);
    slice memo_and_timeout_height = tx_body.at(1);
    tuple ext_opts = tx_body.at(2);
    tuple non_critical_ext_opts = tx_body.at(3);

    ;; tx_body handle
    ;; tody encode the raw_msg
    (int len, tuple tx_body_tuple) = tx_body::encode(msgs, memo_and_timeout_height, ext_opts, non_critical_ext_opts);
    
    slice tx_body_prefix_len = begin_cell()
                                .store_slice(uvarint::encode(10))
                                .store_slice(uvarint::encode(len))
                                .end_cell().begin_parse();

    return_tuple~tpush(tx_body_prefix_len);

    int i = 0;
    int tx_body_tuple_len = tx_body_tuple.tlen();
    while(i < tx_body_tuple_len){
        slice tx_chunk = tx_body_tuple.at(i);
        return_tuple~tpush(tx_chunk);
        i += 1;
    }

<<<<<<< HEAD

=======
>>>>>>> ad3db0f (fix length of tx body)
    ;; auth_info hanle
    tuple auth_info_tuple = auth_info::encode(sign_infos, fees, tip);
    int auth_info_len = auth_info::encode_length(sign_infos, fees, tip);

    slice auth_info_prefix_len = begin_cell()
                                .store_slice(uvarint::encode(18))
                                .store_slice(uvarint::encode(auth_info_len))
                                .end_cell().begin_parse();

    return_tuple~tpush(auth_info_prefix_len);
<<<<<<< HEAD
=======
    ~dump(auth_info_prefix_len);
>>>>>>> ad3db0f (fix length of tx body)

    int auth_info_len = auth_info_tuple.tlen();
    int i = 0;
    while(i < auth_info_len){
        slice auth_chunk = auth_info_tuple.at(i);
        return_tuple~tpush(auth_chunk);
        i += 1;
    }

    ;; signatures handle
    int i = 0;
    int signatures_len = signatures.tlen();
    builder signature_builder = begin_cell()
                                .store_slice(uvarint::encode(26))
                                .store_slice(uvarint::encode(64)); ;; signature length

    ;; normaly we support single signature mode
    while(i < signatures_len){
        slice signature = signatures.at(i);
        signature_builder = signature_builder.store_slice(signature);
        i += 1;
    }

    return_tuple~tpush(signature_builder.end_cell().begin_parse());

    return return_tuple;
}