#include "varint.fc";

;;  function _length (len) {
;;     return lengthType.encodingLength(value.length) + value.length
;;   }
 
(int) varbuffer::encode_length(slice value) {            
    int len = value.slice_bits() >> 3;
    return varint::encode_length(0, len) + len;    
}

;; (slice) varbuffer::encode(cell buffer, int offset) {

;; }

 
;;  encode: function encode (value, buffer, offset) {
;;       if (!Buffer.isBuffer(value)) throw new TypeError('value must be a Buffer instance')
;;       if (!buffer) buffer = Buffer.allocUnsafe(_length(value))
;;       if (!offset) offset = 0
;;       lengthType.encode(value.length, buffer, offset)
;;       offset += lengthType.encode.bytes
;;       if (offset + value.length > buffer.length) throw new RangeError('destination buffer is too small')
;;       value.copy(buffer, offset, 0, value.length)
;;       encode.bytes = lengthType.encode.bytes + value.length
;;       return buffer
;;     },
;;     decode: function decode (buffer, offset, end) {
;;       if (!offset) offset = 0
;;       if (!end) end = buffer.length
;;       var blength = lengthType.decode(buffer, offset, end)
;;       offset += lengthType.decode.bytes
;;       if (offset + blength > end) throw new RangeError('not enough data for decode')
;;       decode.bytes = lengthType.decode.bytes + blength
;;       return Buffer.from(buffer.slice(offset, offset + blength))
;;     },
    