;; encode(message: SignerInfo, writer: BinaryWriter = BinaryWriter.create()): BinaryWriter {
;;     if (message.publicKey !== undefined) {
;;       Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
;;     }
;;     if (message.modeInfo !== undefined) {
;;       ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();
;;     }
;;     if (message.sequence !== BigInt(0)) {
;;       writer.uint32(24).uint64(message.sequence);
;;     }
;;     return writer;
;;   },

;; {
;;     publicKey: {
;;         typeUrl: '/cosmos.crypto.secp256k1.PubKey',
;;         value: <Buffer 0a 21 02 a5 b6 ed 42 f3 c5 8a 8d dc c6 f5 fa ee 44 94 71 26 78 6a 55 8a 88 53 a4 65 c2 e2 d0 ee b0 4a 67>
;;     },
;;     modeInfo: { single: [Object], multi: undefined },
;;     sequence: Long { low: 274922, high: 0, unsigned: true }
;; }

#include "any_google.fc";
#include "varint.fc";

tuple signer_info::encode(tuple ds) {
    slice type_url = ds.at(0);
    tuple value = ds.at(1);
    slice mode_info = ds.at(2);
    int sequence = ds.at(3);

    tuple return_tuple = empty_tuple();
    if (type_url.slice_empty?() != -1) {
        builder inner_cell = begin_cell();
        (int encode_any_len, slice encode_type_url, tuple value_encoded) = any::encode(type_url,value);
        inner_cell = inner_cell.store_slice()

    }
    return ();
}