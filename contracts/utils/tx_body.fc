#include "varint.fc";
#include "any_google.fc";
;; #include "helper.fc";

;; return encode_len and tuple
(int, tuple, slice) tx_body::encode(slice ds)
{       
    slice messages = ds~load_ref().begin_parse();
    slice memo_and_timeout_height = ds~load_ref().begin_parse();
    slice ext_opts = ds~load_ref().begin_parse();
    slice non_critical_ext_opts = ds~load_ref().begin_parse();

    tuple return_tuple = empty_tuple();
    int tx_body_len = 0;
    while(messages.slice_refs_empty?() == 0){
        slice next_ref = messages~load_ref().begin_parse();
        slice msg = messages~load_ref().begin_parse();

        builder message_builder = begin_cell();
        message_builder = message_builder.store_slice(varuint::encode(10));
        (int any_len, slice encode_type_url, tuple value_encoded) = any::encode(msg);
        slice pre_encoded = message_builder
                                .store_slice(varuint::encode(any_len))
                                .end_cell().begin_parse();

        tx_body_len += pre_encoded.slice_bits() >> 3;
        return_tuple~tpush(pre_encoded);
        return_tuple~tpush(encode_type_url);

        int j = 0;
        int value_encoded_len = value_encoded.tlen();
        ;; flat all value to return_tuple
        while(j < value_encoded_len){
            return_tuple~tpush(value_encoded.at(j));
            j += 1;
        }
        tx_body_len += any_len;
        messages = next_ref;
    }
    
    ;; builder memo_and_timeout_height_builder = begin_cell();
    builder prefix = begin_cell();
    builder first_memo = begin_cell();
    builder second_memo = begin_cell();
    builder suffix = begin_cell();

    if(memo_and_timeout_height.slice_empty?() != -1){
        slice memo = memo_and_timeout_height~load_ref().begin_parse();
        ~dump(memo_and_timeout_height);
        if (memo_and_timeout_height.slice_empty?() != -1) {
            int timeout_height = memo_and_timeout_height~load_uint(64); ;;64 bit
            suffix = suffix.store_slice(varuint::encode(24));
            suffix = suffix.store_slice(uvarint_64::encode(timeout_height));
        }
       
        if(memo.slice_empty?() != -1){
            prefix = prefix.store_slice(varuint::encode(18));
            int len = (memo.slice_bits() >> 3) / 2;
            
            int i = 0;
            while (i < len) {
                int number = memo~load_uint(8);
                int quotient = number / 16;
                int remainder = number - quotient * 16;

                if (quotient >= 10) {
                    quotient += 55;
                } else {
                    quotient += 48;
                }
                if (remainder >= 10) {
                    remainder += 55;
                } else {
                    remainder += 48;
                }
                first_memo = first_memo.store_uint(quotient, 8).store_uint(remainder, 8);
                i += 1;
            }

            while (memo.slice_empty?() != -1) {
                int number = memo~load_uint(8);
                int quotient = number / 16;
                int remainder = number - quotient * 16;

                if (quotient >= 10) {
                    quotient += 55;
                } else {
                    quotient += 48;
                }
                if (remainder >= 10) {
                    remainder += 55;
                } else {
                    remainder += 48;
                }
                second_memo = second_memo.store_uint(quotient, 8).store_uint(remainder, 8);
            }
        }
    }

    ;; slice memo_and_timeout_height_slice = memo_and_timeout_height_builder.end_cell().begin_parse();

    slice prefix_slice = prefix.end_cell().begin_parse();
    slice first_memo_slice = first_memo.end_cell().begin_parse();
    slice second_memo_slice = second_memo.end_cell().begin_parse();
    slice suffix_slice = suffix.end_cell().begin_parse();

    if(prefix_slice.slice_empty?() != -1){
        int memo_len = (slice_bits(first_memo_slice) + slice_bits(second_memo_slice)) >> 3;
        slice encoded_memo_len = varuint::encode(memo_len);
        return_tuple~tpush(prefix_slice);
        return_tuple~tpush(encoded_memo_len);
        return_tuple~tpush(first_memo_slice);
        return_tuple~tpush(second_memo_slice);
        return_tuple~tpush(suffix_slice);
        tx_body_len += (slice_bits(encoded_memo_len) + slice_bits(prefix_slice) + slice_bits(first_memo_slice) + slice_bits(second_memo_slice) + slice_bits(suffix_slice)) >> 3;
    }
    
    while(ext_opts.slice_refs_empty?() != -1){
        slice next_ref = ext_opts~load_ref().begin_parse();
        slice msg = ext_opts~load_ref().begin_parse();
        builder ext_opt_builder = begin_cell();
        ext_opt_builder = ext_opt_builder.store_slice(varuint::encode(8186));
        (int any_len, slice encode_type_url, tuple value_encoded) = any::encode(msg);
        slice pre_encoded = ext_opt_builder
                                .store_slice(varuint::encode(any_len))
                                .end_cell()
                                .begin_parse();
        tx_body_len += pre_encoded.slice_bits() >> 3;
        return_tuple~tpush(pre_encoded);
        return_tuple~tpush(encode_type_url);
        int j = 0;
        int value_encoded_len = value_encoded.tlen();
        ;; append all value to return_tuple
        while(j < value_encoded_len){
            return_tuple~tpush(value_encoded.at(j));
            ;; tx_body_len += value_encoded.at(j).slice_bits() >> 3;
            j += 1;
        }
        tx_body_len += any_len;
        ext_opts = next_ref;
    }

    while(non_critical_ext_opts.slice_refs_empty?() != -1){
        slice next_ref = non_critical_ext_opts~load_ref().begin_parse();
        slice msg = non_critical_ext_opts~load_ref().begin_parse();
        builder non_critical_ext_opts_builder = begin_cell();
        non_critical_ext_opts_builder = non_critical_ext_opts_builder.store_slice(varuint::encode(16378));
        (int any_len, slice encode_type_url, tuple value_encoded) = any::encode(msg);

        slice pre_encoded = non_critical_ext_opts_builder
                            .store_slice(varuint::encode(any_len))
                            .end_cell()
                            .begin_parse();

        tx_body_len += pre_encoded.slice_bits() >> 3;

        return_tuple~tpush(pre_encoded);
        return_tuple~tpush(encode_type_url);

        int j = 0;
        int value_encoded_len = value_encoded.tlen();
        ;; append all value to return_tuple
        while(j < value_encoded_len){
            return_tuple~tpush(value_encoded.at(j));
            j += 1;
        }

        tx_body_len += any_len;
        non_critical_ext_opts = next_ref;
    }

    return (tx_body_len, return_tuple, begin_cell().end_cell().begin_parse());
}
